# construct a signal server object with various models. each model will have an output name.
# a signal generator will generate signals from named inputs generated by models
# the signal server will precompute signals generated by signal generators and serve requests for
# specific dates and specific pairs

import uuid
# when creating the signal server, the pairs and date range for precomputation will be specified
# the signal server will get the required features for the datasets from models
from typing import Optional

import logging
import numpy as np
from pandas.core.base import DataError

from lambdatrader.constants import M5
from lambdatrader.models.tradesignal import (
    TradeSignal, PriceEntry, PriceTakeProfitSuccessExit, TimeoutStopLossFailureExit,
)
from lambdatrader.signals.data_analysis.df_datasets import (
    DFDataset, SingleValueDatasetDescriptor,
)
from lambdatrader.signals.data_analysis.df_values import CloseAvgReturn, MaxReturn, CloseReturn
from lambdatrader.signals.data_analysis.factories import ValueSets
from lambdatrader.signals.data_analysis.models import NotTrainedException
from lambdatrader.signals.generators.generators.base import BaseSignalGenerator
from lambdatrader.signals.generators.generators.linreg import MAX_ALLOWED_TICK_CANDLE_DIFF
from lambdatrader.utilities.utils import seconds


class SignalServer:

    def __init__(self, models, signal_converter, pairs, pc_start_date, pc_end_date,
                 model_per_pair=False, pair_models=None):
        self.models = list(models)
        self.signal_converter = signal_converter

        self.pairs = pairs
        self.pc_start_date = pc_start_date
        self.pc_end_date = pc_end_date
        self.model_per_pair = model_per_pair
        self.pair_models = pair_models

        if self.model_per_pair:
            for pair, models in self.pair_models.items():
                print()
                print('training', pair)
                print()
                try:
                    for model in models:
                            model.train()
                except DataError:
                    print('DataError while training ', pair)
                except Exception as e:
                    # TODO tmp handling
                    if str(e).find('inputs are all NaN') >= 0:
                        pass
                    else:
                        raise e
        else:
            for model in self.models:
                model.train()

        self._preds = {}
        self._signals = {}
        self._pair_start_dates = {}

        self._precompute()
        self._compute_signals()

    def _precompute(self):
        for pair in self.pairs:
            try:
                self._preds[pair] = {}
                if self.model_per_pair:
                    models = self.pair_models[pair]
                else:
                    models = self.models
                for model in models:
                    model_dd = model.dataset_descriptor.training
                    feature_set = model_dd.feature_set
                    dd = SingleValueDatasetDescriptor(
                        pairs=[pair],
                        feature_set=feature_set,
                        value_set=ValueSets.dummy(),
                        start_date=self.pc_start_date,
                        end_date=self.pc_end_date,
                        interleaved=False
                    )
                    df = (DFDataset.
                          compute_from_descriptor(descriptor=dd,
                                                  normalize=False,
                                                  error_on_missing=True)
                          .add_feature_df()
                          .get())[0]
                    preds = model.predict_df(df)
                    # print(preds)
                    self._pair_start_dates[pair] = int(df.index[0].timestamp())
                    # print('pair start', datetime.utcfromtimestamp(self._pair_start_dates[pair]))
                    self._preds[pair][model.value_name] = preds
            except (KeyError, NotTrainedException):
                del self._preds[pair]
                print('KeyError or not trained while precomputing {}'.format(pair))

    def _compute_signals(self):
        for pair, model_outputs in self._preds.items():
            self._signals[pair] = self.signal_converter.convert(model_outputs)

    def get_signal(self, pair, date):
        offset = (date - self._pair_start_dates[pair]) // M5.seconds()
        signal_vec = self._signals[pair]
        # print('gon try')
        try:
            if signal_vec.signal[offset]:
                return SingleTradeSignal(signal_vec.tp_level[offset], signal_vec.timeout[offset])
            else:
                # print('no sig')
                return None
        except IndexError:
            raise KeyError('{} for date and offset {} {}'.format(pair, date, offset))


class SignalConverter:

    def convert(self, model_output_dict):
        raise NotImplementedError


class CloseAvgReturnMaxReturnSignalConverter(SignalConverter):
    TP_MODE__MAX_PRED = 'max_pred'
    TP_MODE__CAVG_PRED = 'close_avg_pred'

    def __init__(self, n_candles=48, c_thr=0.02, m_thr=0.02, tp_mode=TP_MODE__MAX_PRED):
        self.n_candles = n_candles
        self.c_thr = c_thr
        self.m_thr = m_thr
        self.tp_mode = tp_mode

    def convert(self, model_output_dict):
        cavg_return_name = CloseAvgReturn(n_candles=self.n_candles).name
        max_return_name = MaxReturn(n_candles=self.n_candles).name

        cavg = model_output_dict[cavg_return_name]
        _max = model_output_dict[max_return_name]

        n = len(cavg)

        signal = np.logical_and(cavg > self.c_thr, _max > self.m_thr)

        tp_vec = np.full(n, np.nan)

        if self.tp_mode == self.TP_MODE__CAVG_PRED:
            tp_vec[signal] = cavg[signal]
        elif self.tp_mode == self.TP_MODE__MAX_PRED:
            tp_vec[signal] = _max[signal]

        timeout = self.n_candles * M5.seconds()

        return TradeSignalVector.compute_with_fixed_timeout(signal, tp_vec, timeout)


class CloseReturnMaxReturnSignalConverter(SignalConverter):
    TP_MODE__MAX_PRED = 'max_pred'
    TP_MODE__CLOSE_PRED = 'close_pred'

    def __init__(self, n_candles=48, c_thr=0.02, m_thr=0.02, tp_mode=TP_MODE__MAX_PRED):
        self.n_candles = n_candles
        self.c_thr = c_thr
        self.m_thr = m_thr
        self.tp_mode = tp_mode

    def convert(self, model_output_dict):
        cavg_return_name = CloseReturn(n_candles=self.n_candles).name
        max_return_name = MaxReturn(n_candles=self.n_candles).name

        cavg = model_output_dict[cavg_return_name]
        _max = model_output_dict[max_return_name]

        n = len(cavg)

        signal = np.logical_and(cavg > self.c_thr, _max > self.m_thr)

        tp_vec = np.full(n, np.nan)

        if self.tp_mode == self.TP_MODE__CLOSE_PRED:
            tp_vec[signal] = cavg[signal]
        elif self.tp_mode == self.TP_MODE__MAX_PRED:
            tp_vec[signal] = _max[signal]

        timeout = self.n_candles * M5.seconds()

        return TradeSignalVector.compute_with_fixed_timeout(signal, tp_vec, timeout)


# In VectorTradeSignal, there are two columns. If there is no signal, the corresponding columns will
# be nan and 0, if there is a signal, first column represents the tp level, second column represents
# the timeout in seconds

class TradeSignalVector:

    def __init__(self, signal, tp_level, timeout):
        self.signal = signal
        self.tp_level = tp_level
        self.timeout = timeout

    @classmethod
    def compute_with_fixed_timeout(cls, signal, tp_level, timeout_value):
        timeout = np.zeros(len(signal), dtype=int)
        timeout[signal] = timeout_value
        return TradeSignalVector(signal, tp_level, timeout)


class SingleTradeSignal:

    def __init__(self, tp_level, timeout):
        self.tp_level = tp_level
        self.timeout = timeout


class ModelPredSignalGenerator(BaseSignalGenerator):

    def __init__(self, market_info, signal_server: SignalServer, live=False, silent=False,
                 pairs=None, exclude_external=True, **kwargs):
        super().__init__(market_info, live=live, silent=silent)
        self.signal_server = signal_server
        self.__allowed_pairs = pairs

        self.EXCLUDE_EXTERNAL_SIGNAL_PAIRS = exclude_external

        self.id = uuid.uuid1()

    def get_algo_descriptor(self):
        return {
            'CLASS_NAME': self.__class__.__name__,
            'SIGNAL_SERVER': self.signal_server,
            'ALLOWED_PAIRS': self.__allowed_pairs,
            'EXCLUDE_EXTERNAL_SIGNAL_PAIRS': self.EXCLUDE_EXTERNAL_SIGNAL_PAIRS,
        }

    def get_allowed_pairs(self):
        return self._get_allowed_pairs()
        # return sorted(self.market_info.get_active_pairs())
        # return ['BTC_LTC', 'BTC_ETH', 'BTC_ETC', 'BTC_XMR', 'BTC_SYS', 'BTC_VIA', 'BTC_SC']
        # return ['BTC_LTC']
        # return ['BTC_XMR']
        # return ['BTC_SYS']
        # return ['BTC_ETH']
        # return ['BTC_ETC']
        # return ['BTC_VIA']
        # return ['BTC_RADS']
        # return ['BTC_XRP']
        # return ['BTC_SC']

    def _get_allowed_pairs(self):
        if self.__allowed_pairs:
            return sorted(set(self.market_info.get_active_pairs()) & set(self.__allowed_pairs))
        else:
            return sorted(self.market_info.get_active_pairs())

    def pre_analyze_market(self, tracked_signals):
        pass

    def analyze_pair(self, pair, tracked_signals) -> Optional[TradeSignal]:

        if self.EXCLUDE_EXTERNAL_SIGNAL_PAIRS:
            signals_considered = tracked_signals
        else:
            signals_considered = filter(lambda s: 'origin' in s and s['origin'] == self.id,
                                        tracked_signals)

        if pair in [signal.pair for signal in signals_considered]:
            self.debug('pair_already_in_tracked_signals:%s', pair)
            return

        try:
            latest_candle = self.market_info.get_pair_candlestick(pair=pair)
            latest_candle_date = latest_candle.date

            signal = self.signal_server.get_signal(pair=pair, date=latest_candle_date)
        except KeyError as e:
            self.logger.error('KeyError: %s: %s', pair, e)
            return

        if signal is None:
            return

        latest_ticker = self.market_info.get_pair_ticker(pair=pair)
        price = latest_ticker.lowest_ask
        market_date = self.market_date

        if self.LIVE:
            if price > latest_candle.close * (1+MAX_ALLOWED_TICK_CANDLE_DIFF):
                self.logger.info('lowest ask higher than latest candlestick close, '
                                 'dismissing signal.')
                return

        target_price = price * (1 + signal.tp_level)

        self.debug('market_date:%s', str(market_date))
        self.debug('latest_ticker:%s:%s', pair, str(latest_ticker))
        self.debug('target_price:%s', str(target_price))

        target_duration = seconds(seconds=signal.timeout)

        entry = PriceEntry(price)
        success_exit = PriceTakeProfitSuccessExit(price=target_price)
        failure_exit = TimeoutStopLossFailureExit(timeout=target_duration)

        trade_signal = TradeSignal(date=market_date, exchange=None, pair=pair, entry=entry,
                                   success_exit=success_exit, failure_exit=failure_exit,
                                   meta={'origin': self.id})

        self.logger.debug('trade_signal:%s', str(trade_signal))

        return trade_signal
